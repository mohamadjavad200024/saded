{"version":3,"sources":["../../../lib/chat/schema.ts","../../../lib/cache.ts","../../../lib/rate-limit.ts"],"sourcesContent":["import { getRow, getRows, runQuery } from \"@/lib/db/index\";\n\nexport type ChatSchemaInfo = {\n  chatHasUserId: boolean;\n  messageHasUserId: boolean;\n};\n\ntype Cached = { value: ChatSchemaInfo; expiresAt: number };\n\nconst CACHE_KEY = \"__saded_chat_schema_info\";\nconst TTL_MS = 5 * 60 * 1000;\n\nfunction getCache(): Cached | null {\n  const g: any = globalThis as any;\n  const v = g[CACHE_KEY] as Cached | undefined;\n  if (!v) return null;\n  if (typeof v.expiresAt !== \"number\" || v.expiresAt < Date.now()) return null;\n  return v;\n}\n\nfunction setCache(value: ChatSchemaInfo) {\n  const g: any = globalThis as any;\n  g[CACHE_KEY] = { value, expiresAt: Date.now() + TTL_MS } satisfies Cached;\n}\n\nexport async function ensureChatTables(): Promise<void> {\n  await runQuery(`\n    CREATE TABLE IF NOT EXISTS quick_buy_chats (\n      id VARCHAR(255) PRIMARY KEY,\n      userId VARCHAR(255) NULL,\n      customerName VARCHAR(255) NOT NULL,\n      customerPhone VARCHAR(255) NOT NULL,\n      customerEmail VARCHAR(255),\n      status VARCHAR(50) NOT NULL DEFAULT 'active',\n      createdAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      updatedAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n    );\n  `);\n\n  await runQuery(`\n    CREATE TABLE IF NOT EXISTS chat_messages (\n      id VARCHAR(255) PRIMARY KEY,\n      chatId VARCHAR(255) NOT NULL,\n      userId VARCHAR(255) NULL,\n      text TEXT,\n      sender VARCHAR(50) NOT NULL,\n      attachments JSON DEFAULT '[]',\n      status VARCHAR(50) DEFAULT 'sent',\n      createdAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n  `);\n\n  await runQuery(`\n    CREATE TABLE IF NOT EXISTS chat_attachments (\n      id VARCHAR(255) PRIMARY KEY,\n      messageId VARCHAR(255) NOT NULL,\n      type VARCHAR(50) NOT NULL,\n      filePath VARCHAR(500),\n      fileName VARCHAR(255),\n      fileSize BIGINT,\n      fileUrl VARCHAR(500),\n      createdAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n    );\n  `);\n\n  // Best-effort migrations (may fail on limited DB permissions; that's OK)\n  try {\n    const chatCols = await getRows<{ COLUMN_NAME: string }>(\n      `SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'quick_buy_chats'`\n    );\n    const chatColSet = new Set(chatCols.map((c) => String(c.COLUMN_NAME)));\n    if (!chatColSet.has(\"userId\")) {\n      await runQuery(`ALTER TABLE quick_buy_chats ADD COLUMN userId VARCHAR(255) NULL`);\n    }\n    try {\n      await runQuery(`CREATE INDEX idx_quick_buy_chats_userId ON quick_buy_chats (userId)`);\n    } catch (err: any) {\n      // ignore duplicate key errors (index already exists)\n      if (err?.code !== 'ER_DUP_KEYNAME') {\n        // Only log non-duplicate errors in development\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Index creation skipped (may already exist):', err?.code);\n        }\n      }\n    }\n    try {\n      await runQuery(`CREATE INDEX idx_quick_buy_chats_customerPhone ON quick_buy_chats (customerPhone)`);\n    } catch (err: any) {\n      // ignore duplicate key errors (index already exists)\n      if (err?.code !== 'ER_DUP_KEYNAME') {\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Index creation skipped (may already exist):', err?.code);\n        }\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  try {\n    const msgCols = await getRows<{ COLUMN_NAME: string }>(\n      `SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'chat_messages'`\n    );\n    const msgColSet = new Set(msgCols.map((c) => String(c.COLUMN_NAME)));\n    if (!msgColSet.has(\"userId\")) {\n      await runQuery(`ALTER TABLE chat_messages ADD COLUMN userId VARCHAR(255) NULL`);\n    }\n    try {\n      await runQuery(`CREATE INDEX idx_chat_messages_userId ON chat_messages (userId)`);\n    } catch (err: any) {\n      // ignore duplicate key errors (index already exists)\n      if (err?.code !== 'ER_DUP_KEYNAME') {\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Index creation skipped (may already exist):', err?.code);\n        }\n      }\n    }\n    try {\n      await runQuery(`CREATE INDEX idx_chat_messages_chatId ON chat_messages (chatId)`);\n    } catch (err: any) {\n      // ignore duplicate key errors (index already exists)\n      if (err?.code !== 'ER_DUP_KEYNAME') {\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Index creation skipped (may already exist):', err?.code);\n        }\n      }\n    }\n    if (!msgColSet.has(\"updatedAt\")) {\n      await runQuery(`ALTER TABLE chat_messages ADD COLUMN updatedAt TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP`);\n    }\n  } catch {\n    // ignore\n  }\n\n  // Ensure FK/indexes are present where possible (best-effort)\n  try {\n    await runQuery(`ALTER TABLE chat_messages ADD CONSTRAINT fk_chat_messages_chatId FOREIGN KEY (chatId) REFERENCES quick_buy_chats(id) ON DELETE CASCADE`);\n  } catch (err: any) {\n    // ignore duplicate constraint errors (constraint already exists)\n    if (err?.code !== 'ER_DUP_KEY' && err?.code !== 'ER_CANT_CREATE_TABLE' && err?.code !== 'ER_DUP_ENTRY') {\n      if (process.env.NODE_ENV === 'development') {\n        console.debug('Foreign key creation skipped (may already exist):', err?.code);\n      }\n    }\n  }\n  try {\n    await runQuery(`ALTER TABLE chat_attachments ADD CONSTRAINT fk_chat_attachments_messageId FOREIGN KEY (messageId) REFERENCES chat_messages(id) ON DELETE CASCADE`);\n  } catch (err: any) {\n    // ignore duplicate constraint errors (constraint already exists)\n    if (err?.code !== 'ER_DUP_KEY' && err?.code !== 'ER_CANT_CREATE_TABLE' && err?.code !== 'ER_DUP_ENTRY') {\n      if (process.env.NODE_ENV === 'development') {\n        console.debug('Foreign key creation skipped (may already exist):', err?.code);\n      }\n    }\n  }\n}\n\nexport async function getChatSchemaInfo(): Promise<ChatSchemaInfo> {\n  const cached = getCache();\n  if (cached) return cached.value;\n\n  const [chatHasUserId, messageHasUserId] = await Promise.all([\n    getRow<{ cnt: number }>(\n      `SELECT COUNT(*) as cnt\n       FROM INFORMATION_SCHEMA.COLUMNS\n       WHERE TABLE_SCHEMA = DATABASE()\n         AND TABLE_NAME = 'quick_buy_chats'\n         AND COLUMN_NAME = 'userId'`\n    ).then((r) => Number(r?.cnt || 0) > 0).catch(() => false),\n    getRow<{ cnt: number }>(\n      `SELECT COUNT(*) as cnt\n       FROM INFORMATION_SCHEMA.COLUMNS\n       WHERE TABLE_SCHEMA = DATABASE()\n         AND TABLE_NAME = 'chat_messages'\n         AND COLUMN_NAME = 'userId'`\n    ).then((r) => Number(r?.cnt || 0) > 0).catch(() => false),\n  ]);\n\n  const info = { chatHasUserId, messageHasUserId };\n  setCache(info);\n  return info;\n}\n\n\n","/**\r\n * Simple in-memory cache for API responses\r\n * Used to reduce database queries and improve performance\r\n */\r\n\r\ninterface CacheEntry<T> {\r\n  data: T;\r\n  timestamp: number;\r\n  ttl: number; // Time to live in milliseconds\r\n}\r\n\r\nclass SimpleCache {\r\n  private cache = new Map<string, CacheEntry<any>>();\r\n  private maxSize = 1000; // Maximum number of entries\r\n\r\n  /**\r\n   * Get value from cache\r\n   */\r\n  get<T>(key: string): T | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) {\r\n      return null;\r\n    }\r\n\r\n    // Check if entry has expired\r\n    const now = Date.now();\r\n    if (now - entry.timestamp > entry.ttl) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry.data as T;\r\n  }\r\n\r\n  /**\r\n   * Set value in cache\r\n   */\r\n  set<T>(key: string, data: T, ttl: number = 60000): void {\r\n    // Remove oldest entries if cache is full\r\n    if (this.cache.size >= this.maxSize) {\r\n      const firstKey = this.cache.keys().next().value;\r\n      if (firstKey !== undefined) {\r\n        this.cache.delete(firstKey);\r\n      }\r\n    }\r\n\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now(),\r\n      ttl,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete value from cache\r\n   */\r\n  delete(key: string): void {\r\n    this.cache.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n\r\n  /**\r\n   * Clear expired entries\r\n   */\r\n  clearExpired(): void {\r\n    const now = Date.now();\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (now - entry.timestamp > entry.ttl) {\r\n        this.cache.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache size\r\n   */\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const cache = new SimpleCache();\r\n\r\n// Clean up expired entries every 5 minutes\r\nif (typeof setInterval !== 'undefined') {\r\n  setInterval(() => {\r\n    cache.clearExpired();\r\n  }, 5 * 60 * 1000);\r\n}\r\n\r\n/**\r\n * Cache key generators\r\n */\r\nexport const cacheKeys = {\r\n  chat: (chatId: string) => `chat:${chatId}`,\r\n  chatMessages: (chatId: string, page?: number, limit?: number) => \r\n    `chat:messages:${chatId}:${page || 1}:${limit || 50}`,\r\n  chatList: (page?: number, limit?: number) => \r\n    `chat:list:${page || 1}:${limit || 50}`,\r\n  products: (page?: number, limit?: number, filters?: string) => \r\n    `products:${page || 1}:${limit || 50}:${filters || ''}`,\r\n  product: (productId: string) => `product:${productId}`,\r\n  categories: () => `categories:all`,\r\n  category: (categoryId: string) => `category:${categoryId}`,\r\n  orders: (filters?: string) => `orders:${filters || ''}`,\r\n  order: (orderId: string) => `order:${orderId}`,\r\n};\r\n\r\n/**\r\n * Helper to wrap async function with cache\r\n */\r\nexport async function withCache<T>(\r\n  key: string,\r\n  fn: () => Promise<T>,\r\n  ttl: number = 60000 // Default 1 minute\r\n): Promise<T> {\r\n  // Try to get from cache first\r\n  const cached = cache.get<T>(key);\r\n  if (cached !== null) {\r\n    return cached;\r\n  }\r\n\r\n  // Execute function and cache result\r\n  const result = await fn();\r\n  cache.set(key, result, ttl);\r\n  return result;\r\n}\r\n\r\n","/**\r\n * Simple in-memory rate limiter\r\n * For production, consider using Redis-based rate limiting\r\n */\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport crypto from \"crypto\";\r\n\r\ninterface RateLimitEntry {\r\n  count: number;\r\n  resetTime: number;\r\n}\r\n\r\nclass RateLimiter {\r\n  private store = new Map<string, RateLimitEntry>();\r\n  private cleanupInterval: NodeJS.Timeout | null = null;\r\n\r\n  /**\r\n   * Check if request should be rate limited\r\n   * @param key - Unique identifier (e.g., IP address, user ID)\r\n   * @param maxRequests - Maximum number of requests\r\n   * @param windowMs - Time window in milliseconds\r\n   * @returns true if rate limited, false otherwise\r\n   */\r\n  isRateLimited(key: string, maxRequests: number, windowMs: number): boolean {\r\n    const now = Date.now();\r\n    const entry = this.store.get(key);\r\n\r\n    if (!entry || now > entry.resetTime) {\r\n      // Create new entry or reset expired entry\r\n      this.store.set(key, {\r\n        count: 1,\r\n        resetTime: now + windowMs,\r\n      });\r\n      return false;\r\n    }\r\n\r\n    if (entry.count >= maxRequests) {\r\n      return true; // Rate limited\r\n    }\r\n\r\n    // Increment count\r\n    entry.count++;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get remaining requests for a key\r\n   */\r\n  getRemaining(key: string, maxRequests: number): number {\r\n    const entry = this.store.get(key);\r\n    if (!entry) {\r\n      return maxRequests;\r\n    }\r\n    return Math.max(0, maxRequests - entry.count);\r\n  }\r\n\r\n  /**\r\n   * Get reset time for a key\r\n   */\r\n  getResetTime(key: string): number | null {\r\n    const entry = this.store.get(key);\r\n    return entry ? entry.resetTime : null;\r\n  }\r\n\r\n  /**\r\n   * Clear expired entries\r\n   */\r\n  cleanup(): void {\r\n    const now = Date.now();\r\n    for (const [key, entry] of this.store.entries()) {\r\n      if (now > entry.resetTime) {\r\n        this.store.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start automatic cleanup\r\n   */\r\n  startCleanup(intervalMs: number = 60000): void {\r\n    if (this.cleanupInterval) {\r\n      return;\r\n    }\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanup();\r\n    }, intervalMs);\r\n  }\r\n\r\n  /**\r\n   * Stop automatic cleanup\r\n   */\r\n  stopCleanup(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all entries\r\n   */\r\n  clear(): void {\r\n    this.store.clear();\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const rateLimiter = new RateLimiter();\r\n\r\n// Start automatic cleanup every minute\r\nrateLimiter.startCleanup(60000);\r\n\r\n/**\r\n * Get client identifier from request\r\n */\r\nexport function getClientId(request: NextRequest): string {\r\n  // Try to get IP from various headers (for proxies/load balancers)\r\n  const candidates = [\r\n    request.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim(),\r\n    request.headers.get(\"x-real-ip\")?.trim(),\r\n    request.headers.get(\"cf-connecting-ip\")?.trim(),\r\n    request.headers.get(\"true-client-ip\")?.trim(),\r\n    request.headers.get(\"fastly-client-ip\")?.trim(),\r\n    request.headers.get(\"x-client-ip\")?.trim(),\r\n  ].filter(Boolean) as string[];\r\n\r\n  const ip = candidates[0] || \"unknown\";\r\n\r\n  // If we can't detect an IP, avoid collapsing ALL users into the same \"unknown\" bucket.\r\n  // This is not a security boundary; it's just to reduce false-positive 429s in hosts that don't pass client IP headers.\r\n  if (ip === \"unknown\") {\r\n    const ua = request.headers.get(\"user-agent\") || \"unknown-ua\";\r\n    const uaHash = crypto.createHash(\"sha256\").update(ua).digest(\"hex\").slice(0, 12);\r\n    return `unknown:${uaHash}`;\r\n  }\r\n\r\n  return ip;\r\n}\r\n\r\n/**\r\n * Rate limit middleware\r\n */\r\nexport function rateLimit(\r\n  maxRequests: number = 100,\r\n  windowMs: number = 60000, // 1 minute default\r\n  keyGenerator?: (request: NextRequest) => string\r\n) {\r\n  return async (request: NextRequest): Promise<Response | null> => {\r\n    const key = keyGenerator ? keyGenerator(request) : getClientId(request);\r\n    // IMPORTANT:\r\n    // Include HTTP method in the key so GET polling does NOT consume POST quotas on the same path.\r\n    // Example: /api/chat uses GET polling frequently; without method separation, POST /api/chat would hit 429 unexpectedly.\r\n    const fullKey = `${request.nextUrl.pathname}:${request.method}:${key}`;\r\n\r\n    if (rateLimiter.isRateLimited(fullKey, maxRequests, windowMs)) {\r\n      const resetTime = rateLimiter.getResetTime(fullKey);\r\n      const remaining = rateLimiter.getRemaining(fullKey, maxRequests);\r\n      \r\n      return new Response(\r\n        JSON.stringify({\r\n          success: false,\r\n          error: \"درخواست‌های شما زیاد است. لطفاً کمی بعد دوباره تلاش کنید.\",\r\n          code: \"RATE_LIMIT_EXCEEDED\",\r\n        }),\r\n        {\r\n          status: 429,\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n            'X-RateLimit-Limit': maxRequests.toString(),\r\n            'X-RateLimit-Remaining': remaining.toString(),\r\n            'X-RateLimit-Reset': resetTime?.toString() || '',\r\n            'Retry-After': Math.ceil((resetTime ? resetTime - Date.now() : windowMs) / 1000).toString(),\r\n          },\r\n        }\r\n      );\r\n    }\r\n\r\n    return null; // Not rate limited\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}