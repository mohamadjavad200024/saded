{"version":3,"sources":["../../../lib/auth/session.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport crypto from \"crypto\";\nimport { getRow, getRows, runQuery } from \"@/lib/db/index\";\nimport { AppError } from \"@/lib/api-error-handler\";\n\nexport const SESSION_COOKIE_NAME = \"saded_session\";\n\n// Session نامحدود - تا زمانی که کاربر logout نکند\n// برای امنیت، از maxAge بسیار طولانی استفاده می‌کنیم (10 سال)\nconst SESSION_MAX_AGE_SECONDS = 10 * 365 * 24 * 60 * 60; // 10 years in seconds\n\nfunction nowIso(): string {\n  // MySQL friendly datetime (YYYY-MM-DD HH:mm:ss)\n  return new Date().toISOString().slice(0, 19).replace(\"T\", \" \");\n}\n\n// Function removed - sessions are now unlimited, no expiration needed\n\nexport function sha256Hex(input: string): string {\n  return crypto.createHash(\"sha256\").update(input).digest(\"hex\");\n}\n\nexport function isHttpsRequest(request: NextRequest): boolean {\n  const proto = request.headers.get(\"x-forwarded-proto\") || request.nextUrl.protocol.replace(\":\", \"\");\n  return proto === \"https\";\n}\n\nexport function getSessionCookieOptions(request: NextRequest) {\n  // Important: if your site is served over http (Not secure), Secure cookies won't set.\n  // In development, we use http, so secure must be false\n  const isProduction = process.env.NODE_ENV === \"production\";\n  const isLocalhost = request.nextUrl.hostname === \"localhost\" || \n                      request.nextUrl.hostname === \"127.0.0.1\" ||\n                      request.nextUrl.hostname === \"::1\";\n  \n  // Never use secure on localhost - it prevents cookie from being set\n  const secure = isProduction && !isLocalhost && isHttpsRequest(request);\n  \n  return {\n    httpOnly: true,\n    secure: secure, // false on localhost, true only in production with HTTPS\n    sameSite: \"lax\" as const, // lax allows cookies to be sent with same-site requests\n    path: \"/\",\n    maxAge: SESSION_MAX_AGE_SECONDS, // 10 years - effectively unlimited until logout\n    // Ensure domain is not set (allows cookie to work on localhost)\n    // domain is not set by default, which is correct for localhost\n    // In development, explicitly set sameSite to 'lax' to ensure cookies work\n    ...(process.env.NODE_ENV === 'development' && {\n      sameSite: \"lax\" as const,\n    }),\n  };\n}\n\nexport async function ensureAuthTables(): Promise<void> {\n  try {\n    // Users table\n    await runQuery(`\n      CREATE TABLE IF NOT EXISTS users (\n      id VARCHAR(255) PRIMARY KEY,\n      name VARCHAR(255) NOT NULL,\n      phone VARCHAR(32) NOT NULL,\n      password VARCHAR(255) NOT NULL,\n      role VARCHAR(50) NOT NULL DEFAULT 'user',\n      enabled BOOLEAN DEFAULT TRUE,\n      createdAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      updatedAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n      UNIQUE KEY uniq_users_phone (phone)\n    )\n  `);\n\n  // If table already existed with different schema/indexes, normalize it:\n  // - Only `phone` should be unique (besides PRIMARY id)\n  // - Remove other UNIQUE indexes that can block registration (e.g. old email unique)\n  // - Ensure phone is NOT NULL\n  try {\n    // Remove invalid rows (NULL/empty phone) to avoid ALTER failures\n    await runQuery(`DELETE FROM users WHERE phone IS NULL OR TRIM(phone) = ''`);\n\n    // Ensure phone column is NOT NULL (keep type small)\n    await runQuery(`ALTER TABLE users MODIFY phone VARCHAR(32) NOT NULL`);\n\n    // Read indexes\n    const indexRows = await getRows<any>(`SHOW INDEX FROM users`);\n    const uniqueIndexToColumns = new Map<string, string[]>();\n\n    for (const r of indexRows) {\n      const keyName = String(r.Key_name ?? r.key_name ?? r.KEY_NAME ?? \"\");\n      const nonUnique = Number(r.Non_unique ?? r.non_unique ?? r.NON_UNIQUE ?? 1);\n      const colName = String(r.Column_name ?? r.column_name ?? r.COLUMN_NAME ?? \"\");\n      if (!keyName || !colName) continue;\n      if (nonUnique !== 0) continue;\n      const cols = uniqueIndexToColumns.get(keyName) || [];\n      cols.push(colName);\n      uniqueIndexToColumns.set(keyName, cols);\n    }\n\n    // Find which unique index (if any) is exactly on phone\n    let phoneUniqueIndexName: string | null = null;\n    for (const [key, cols] of uniqueIndexToColumns.entries()) {\n      if (key === \"PRIMARY\") continue;\n      const normalizedCols = cols.map((c) => c.toLowerCase()).sort();\n      if (normalizedCols.length === 1 && normalizedCols[0] === \"phone\") {\n        phoneUniqueIndexName = key;\n        break;\n      }\n    }\n\n    // Ensure we have a unique index on phone with our preferred name\n    if (!phoneUniqueIndexName) {\n      await runQuery(`ALTER TABLE users ADD UNIQUE KEY uniq_users_phone (phone)`);\n      phoneUniqueIndexName = \"uniq_users_phone\";\n    }\n\n    // Drop any other UNIQUE indexes (only PRIMARY + phone unique should remain)\n    for (const key of uniqueIndexToColumns.keys()) {\n      if (key === \"PRIMARY\") continue;\n      if (key === phoneUniqueIndexName) continue;\n      // Drop (might fail if permissions; ignore)\n      try {\n        await runQuery(`ALTER TABLE users DROP INDEX \\`${key}\\``);\n      } catch {\n        // ignore\n      }\n    }\n  } catch {\n    // Best-effort; do not block auth if ALTER is not permitted\n  }\n\n  // Sessions table\n  // Note: expiresAt is kept for backward compatibility but not enforced (sessions are unlimited)\n  await runQuery(`\n    CREATE TABLE IF NOT EXISTS sessions (\n      id VARCHAR(255) PRIMARY KEY,\n      userId VARCHAR(255) NOT NULL,\n      tokenHash CHAR(64) NOT NULL,\n      expiresAt TIMESTAMP NULL DEFAULT NULL,\n      createdAt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n      lastSeenAt TIMESTAMP NULL DEFAULT NULL,\n      userAgent VARCHAR(255) NULL DEFAULT NULL,\n      ip VARCHAR(64) NULL DEFAULT NULL,\n      UNIQUE KEY uniq_sessions_tokenHash (tokenHash),\n      KEY idx_sessions_userId (userId),\n      KEY idx_sessions_expiresAt (expiresAt)\n    )\n  `);\n  \n    // Migrate existing sessions: set expiresAt to NULL for unlimited sessions\n    try {\n      await runQuery(`UPDATE sessions SET expiresAt = NULL WHERE expiresAt IS NOT NULL`);\n    } catch {\n      // Best-effort migration, ignore errors\n    }\n  } catch (error: any) {\n    // If database is not available, log but don't throw - allow app to continue\n    if (error?.code === 'ECONNRESET' || \n        error?.code === 'PROTOCOL_CONNECTION_LOST' ||\n        error?.code === 'ETIMEDOUT' ||\n        error?.code === 'ECONNREFUSED' ||\n        error?.message?.includes('closed state')) {\n      logger.warn(\"Database connection error in ensureAuthTables, will retry on next request:\", error?.code);\n      // Don't throw - allow route to continue (it will handle the error)\n      return;\n    }\n    // For other errors, log and rethrow\n    logger.error(\"Error ensuring auth tables:\", error);\n    throw error;\n  }\n}\n\nexport type SessionUser = {\n  id: string;\n  name: string;\n  phone: string;\n  role: string;\n  enabled: boolean;\n  createdAt: string;\n};\n\nexport async function createSession(userId: string, request: NextRequest): Promise<string> {\n  await ensureAuthTables();\n\n  const token = crypto.randomBytes(32).toString(\"base64url\");\n  const tokenHash = sha256Hex(token);\n  const sessionId = `sess_${Date.now()}_${crypto.randomBytes(6).toString(\"hex\")}`;\n  // Session نامحدود - expiresAt را NULL می‌گذاریم\n  const expiresAt = null;\n\n  const ua = request.headers.get(\"user-agent\");\n  const ip = request.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim() || null;\n\n  await runQuery(\n    `INSERT INTO sessions (id, userId, tokenHash, expiresAt, createdAt, lastSeenAt, userAgent, ip)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n    [\n      sessionId,\n      userId,\n      tokenHash,\n      expiresAt,\n      nowIso(),\n      nowIso(),\n      ua || null,\n      ip,\n    ]\n  );\n\n  return token;\n}\n\nexport async function getSessionUserFromRequest(request: NextRequest): Promise<SessionUser | null> {\n  // Try to get cookie from both cookies.get() and headers\n  let token = request.cookies.get(SESSION_COOKIE_NAME)?.value;\n  \n  // Fallback: try to parse from cookie header directly\n  if (!token) {\n    const cookieHeader = request.headers.get('cookie');\n    if (cookieHeader) {\n      const cookies = cookieHeader.split(';').map(c => c.trim());\n      for (const cookie of cookies) {\n        const [name, value] = cookie.split('=');\n        if (name === SESSION_COOKIE_NAME && value) {\n          token = decodeURIComponent(value);\n          break;\n        }\n      }\n    }\n  }\n  \n  if (!token) {\n    // Debug: log if cookie is missing - use console.log for visibility\n    const allCookies = request.cookies.getAll();\n    const cookieNames = allCookies.map(c => c.name);\n    const cookieHeader = request.headers.get('cookie');\n    console.log('[Session] ❌ No session cookie found!');\n    console.log('[Session] Available cookies:', cookieNames);\n    console.log('[Session] Looking for cookie:', SESSION_COOKIE_NAME);\n    console.log('[Session] Request URL:', request.url);\n    console.log('[Session] Cookie header:', cookieHeader ? cookieHeader.substring(0, 300) : 'no cookie header');\n    console.log('[Session] Request hostname:', request.nextUrl.hostname);\n    console.log('[Session] Request protocol:', request.nextUrl.protocol);\n    if (process.env.NODE_ENV === 'development') {\n      console.debug('[Session] No session cookie found. Available cookies:', cookieNames);\n    }\n    return null;\n  }\n  \n  console.log('[Session] ✅ Session token found, length:', token.length);\n\n  // Only touch DB if a session cookie exists (prevents hanging on DB when user is not logged in)\n  try {\n    await ensureAuthTables();\n  } catch (error: any) {\n    // If database is not available, return null (user not authenticated)\n    if (error?.code === 'ECONNRESET' || \n        error?.code === 'PROTOCOL_CONNECTION_LOST' ||\n        error?.code === 'ETIMEDOUT' ||\n        error?.code === 'ECONNREFUSED' ||\n        error?.message?.includes('closed state')) {\n      logger.warn(\"Database connection error in getSessionUserFromRequest, returning null:\", error?.code);\n      return null;\n    }\n    // For other errors, rethrow\n    throw error;\n  }\n\n  const tokenHash = sha256Hex(token);\n  let row;\n  try {\n    row = await getRow<{\n      sessionId: string;\n      userId: string;\n      expiresAt: string;\n      enabled: any;\n      role: string;\n      name: string;\n      phone: string;\n      createdAt: string;\n    }>(\n      `SELECT s.id as sessionId, s.userId, s.expiresAt, u.enabled, u.role, u.name, u.phone, u.createdAt\n       FROM sessions s\n       JOIN users u ON u.id = s.userId\n       WHERE s.tokenHash = ?\n       LIMIT 1`,\n      [tokenHash]\n    );\n  } catch (error: any) {\n    // If database is not available, return null (user not authenticated)\n    if (error?.code === 'ECONNRESET' || \n        error?.code === 'PROTOCOL_CONNECTION_LOST' ||\n        error?.code === 'ETIMEDOUT' ||\n        error?.code === 'ECONNREFUSED' ||\n        error?.message?.includes('closed state')) {\n      logger.warn(\"Database connection error in getSessionUserFromRequest query, returning null:\", error?.code);\n      return null;\n    }\n    // For other errors, rethrow\n    throw error;\n  }\n\n  if (!row) return null;\n\n  // Session نامحدود - بررسی expiration را حذف می‌کنیم\n  // فقط اگر expiresAt وجود داشته باشد و منقضی شده باشد، آن را حذف می‌کنیم\n  // (برای backward compatibility با sessions قدیمی)\n  if (row.expiresAt) {\n    const expires = new Date(row.expiresAt);\n    if (!Number.isNaN(expires.getTime()) && expires.getTime() < Date.now()) {\n      // Expired: delete it\n      await runQuery(`DELETE FROM sessions WHERE tokenHash = ?`, [tokenHash]);\n      return null;\n    }\n  }\n\n  // Touch session (ignore errors - not critical)\n  try {\n    await runQuery(`UPDATE sessions SET lastSeenAt = ? WHERE id = ?`, [nowIso(), row.sessionId]);\n  } catch (error: any) {\n    // Ignore connection errors when touching session - not critical\n    if (error?.code === 'ECONNRESET' || \n        error?.code === 'PROTOCOL_CONNECTION_LOST' ||\n        error?.code === 'ETIMEDOUT' ||\n        error?.code === 'ECONNREFUSED' ||\n        error?.message?.includes('closed state')) {\n      // Silent ignore - session touch is not critical\n    } else {\n      // Log other errors but don't fail\n      logger.debug(\"Error touching session (non-critical):\", error?.code);\n    }\n  }\n\n  return {\n    id: row.userId,\n    name: row.name,\n    phone: row.phone,\n    role: row.role || \"user\",\n    enabled: Boolean(row.enabled),\n    createdAt: row.createdAt,\n  };\n}\n\nexport async function clearSession(request: NextRequest): Promise<void> {\n  const token = request.cookies.get(SESSION_COOKIE_NAME)?.value;\n  if (!token) return;\n  await ensureAuthTables();\n  const tokenHash = sha256Hex(token);\n  await runQuery(`DELETE FROM sessions WHERE tokenHash = ?`, [tokenHash]);\n}\n\nexport function setSessionCookie(response: NextResponse, token: string, request: NextRequest) {\n  const options = getSessionCookieOptions(request);\n  \n  // CRITICAL: In Next.js, we should ONLY use response.cookies.set()\n  // Setting headers directly can cause conflicts\n  // Make sure all options are explicitly set\n  response.cookies.set(SESSION_COOKIE_NAME, token, {\n    httpOnly: true,\n    secure: options.secure,\n    sameSite: options.sameSite,\n    path: \"/\",\n    maxAge: options.maxAge,\n    // DO NOT set domain - it breaks localhost\n    // DO NOT set expires - use maxAge instead\n  });\n  \n  // Debug in development\n  if (process.env.NODE_ENV === 'development') {\n    const cookieValue = response.cookies.get(SESSION_COOKIE_NAME)?.value;\n    const allCookies = response.cookies.getAll();\n    console.log('[Session] Cookie set:', {\n      name: SESSION_COOKIE_NAME,\n      hasToken: !!token,\n      tokenLength: token?.length,\n      cookieValueInResponse: !!cookieValue,\n      cookieValueMatches: cookieValue === token,\n      maxAge: options.maxAge,\n      expiresIn: \"unlimited (until logout)\",\n      secure: options.secure,\n      sameSite: options.sameSite,\n      requestHost: request.nextUrl.hostname,\n      requestProtocol: request.nextUrl.protocol,\n      allCookiesCount: allCookies.length,\n      cookieNames: allCookies.map(c => c.name),\n    });\n  }\n}\n\nexport function clearSessionCookie(response: NextResponse, request: NextRequest) {\n  response.cookies.set(SESSION_COOKIE_NAME, \"\", {\n    ...getSessionCookieOptions(request),\n    maxAge: 0,\n  });\n}\n\n\n"],"names":[],"mappings":"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"}