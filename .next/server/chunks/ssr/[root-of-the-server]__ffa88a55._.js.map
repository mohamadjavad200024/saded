{"version":3,"sources":["../../../../components/product/product-detail.tsx/__nextjs-internal-proxy.mjs","../../../../app/products/%5Bid%5D/page.tsx","../../../../lib/db/index.ts","../../../../lib/image-utils.ts","../../../../lib/product-utils.ts"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ProductDetail = registerClientReference(\n    function() { throw new Error(\"Attempted to call ProductDetail() from the server but ProductDetail is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/components/product/product-detail.tsx\",\n    \"ProductDetail\",\n);\n","import type { Metadata } from \"next\";\r\nimport { Header } from \"@/components/layout/header\";\r\nimport { Footer } from \"@/components/layout/footer\";\r\nimport { ProductDetail } from \"@/components/product/product-detail\";\r\nimport { getRow } from \"@/lib/db/index\";\r\nimport type { Product } from \"@/types/product\";\r\nimport { getPlaceholderImage } from \"@/lib/image-utils\";\r\nimport { normalizeImages, normalizeTags, normalizeSpecifications } from \"@/lib/product-utils\";\r\n\r\nconst baseUrl = process.env.NEXT_PUBLIC_URL || \"https://saded.ir\";\r\n\r\nasync function getProduct(id: string): Promise<Product | null> {\r\n  try {\r\n    const product = await getRow<any>(\r\n      \"SELECT * FROM products WHERE id = ? AND enabled = TRUE\",\r\n      [id]\r\n    );\r\n\r\n    if (!product) {\r\n      return null;\r\n    }\r\n\r\n    // Parse JSON fields with normalization\r\n    const parsedProduct: Product = {\r\n      ...product,\r\n      images: normalizeImages(product.images),\r\n      tags: normalizeTags(product.tags),\r\n      specifications: normalizeSpecifications(product.specifications),\r\n      price: Number(product.price),\r\n      originalPrice: product.originalPrice ? Number(product.originalPrice) : undefined,\r\n      stockCount: Number(product.stockCount),\r\n      inStock: Boolean(product.inStock),\r\n      enabled: Boolean(product.enabled),\r\n      vinEnabled: Boolean(product.vinEnabled),\r\n      airShippingEnabled: Boolean(product.airShippingEnabled),\r\n      seaShippingEnabled: Boolean(product.seaShippingEnabled),\r\n      airShippingCost: product.airShippingCost !== null && product.airShippingCost !== undefined \r\n        ? Number(product.airShippingCost) \r\n        : null,\r\n      seaShippingCost: product.seaShippingCost !== null && product.seaShippingCost !== undefined \r\n        ? Number(product.seaShippingCost) \r\n        : null,\r\n      createdAt: product.createdAt instanceof Date ? product.createdAt : new Date(product.createdAt),\r\n      updatedAt: product.updatedAt instanceof Date ? product.updatedAt : new Date(product.updatedAt),\r\n    };\r\n\r\n    return parsedProduct;\r\n  } catch (error) {\r\n    console.error(\"Error fetching product for metadata:\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function generateMetadata({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>;\r\n}): Promise<Metadata> {\r\n  const { id } = await params;\r\n  const product = await getProduct(id);\r\n\r\n  if (!product) {\r\n    return {\r\n      title: \"محصول یافت نشد - ساد\",\r\n      description: \"محصول مورد نظر شما یافت نشد\",\r\n    };\r\n  }\r\n\r\n  const productImage = product.images?.[0] || getPlaceholderImage(1200, 630);\r\n  const productUrl = `${baseUrl}/products/${id}`;\r\n  const price = product.price / 1000; // Convert from Rials to Tomans for display\r\n  const description = product.description || `${product.name} - قطعه خودرو ${product.brand} با بهترین کیفیت و قیمت`;\r\n\r\n  return {\r\n    title: `${product.name} - ساد`,\r\n    description: description.substring(0, 160),\r\n    keywords: [\r\n      product.name,\r\n      product.brand || \"\",\r\n      product.category || \"\",\r\n      \"قطعات خودرو\",\r\n      \"قطعات وارداتی\",\r\n      ...(product.tags || []),\r\n    ],\r\n    alternates: {\r\n      canonical: productUrl,\r\n    },\r\n    openGraph: {\r\n      title: product.name,\r\n      description: description.substring(0, 160),\r\n      url: productUrl,\r\n      siteName: \"ساد - فروشگاه قطعات خودرو\",\r\n      images: [\r\n        {\r\n          url: productImage,\r\n          width: 1200,\r\n          height: 630,\r\n          alt: product.name,\r\n        },\r\n      ],\r\n      locale: \"fa_IR\",\r\n      type: \"website\",\r\n    },\r\n    twitter: {\r\n      card: \"summary_large_image\",\r\n      title: product.name,\r\n      description: description.substring(0, 160),\r\n      images: [productImage],\r\n    },\r\n    robots: {\r\n      index: true,\r\n      follow: true,\r\n      googleBot: {\r\n        index: true,\r\n        follow: true,\r\n        \"max-video-preview\": -1,\r\n        \"max-image-preview\": \"large\",\r\n        \"max-snippet\": -1,\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\nexport default async function ProductDetailPage({\r\n  params,\r\n}: {\r\n  params: Promise<{ id: string }>;\r\n}) {\r\n  const { id } = await params;\r\n  \r\n  return (\r\n    <div className=\"flex min-h-screen flex-col\">\r\n      <Header />\r\n      <main className=\"flex-1 container py-4 sm:py-6 md:py-8\">\r\n        <ProductDetail productId={id} />\r\n      </main>\r\n      <Footer />\r\n    </div>\r\n  );\r\n}\r\n\r\n","/**\n * Database Wrapper\n * \n * این فایل یک interface یکپارچه برای استفاده از MySQL فراهم می‌کند\n */\n\n/**\n * Get single row from database\n */\nexport async function getRow<T extends Record<string, any> = any>(\n  sql: string,\n  params: any[] = []\n): Promise<T | null> {\n  try {\n    const { queryOne } = await import(\"./mysql\");\n    // Convert double-quoted column names to backticks for MySQL\n    const mysqlSql = convertToMySQLSQL(sql);\n    return await queryOne<T>(mysqlSql, params);\n  } catch (error: any) {\n    console.error(\"Database error in getRow:\", {\n      sql,\n      params,\n      error: error?.message,\n      code: error?.code,\n    });\n    throw error;\n  }\n}\n\n/**\n * Get multiple rows from database\n */\nexport async function getRows<T extends Record<string, any> = any>(\n  sql: string,\n  params: any[] = []\n): Promise<T[]> {\n  try {\n    const { queryAll } = await import(\"./mysql\");\n    // Convert double-quoted column names to backticks for MySQL\n    const mysqlSql = convertToMySQLSQL(sql);\n    return await queryAll<T>(mysqlSql, params);\n  } catch (error: any) {\n    console.error(\"Database error in getRows:\", {\n      sql,\n      params,\n      error: error?.message,\n      code: error?.code,\n    });\n    throw error;\n  }\n}\n\n/**\n * Run a query (INSERT, UPDATE, DELETE)\n */\nexport async function runQuery(\n  sql: string,\n  params: any[] = []\n): Promise<{ changes: number; lastInsertRowid?: number }> {\n  const { query } = await import(\"./mysql\");\n  const mysqlSql = convertToMySQLSQL(sql);\n  const result = await query(mysqlSql, params);\n  return {\n    changes: result.affectedRows || result.rowCount || 0,\n    lastInsertRowid: result.insertId || undefined,\n  };\n}\n\n/**\n * Convert SQL to MySQL SQL\n * - Converts double-quoted column names to backticks\n * - Converts PostgreSQL $1, $2, etc. placeholders to MySQL ? placeholders\n * - Converts ON CONFLICT to ON DUPLICATE KEY UPDATE\n * - MySQL uses ? placeholders (already correct)\n */\nfunction convertToMySQLSQL(sql: string): string {\n  let mysqlSql = sql;\n\n  // Convert PostgreSQL $1, $2, etc. placeholders to MySQL ? placeholders\n  // First, extract all $N placeholders and their positions\n  const placeholderRegex = /\\$(\\d+)/g;\n  const placeholders: Array<{ index: number; position: number }> = [];\n  let match;\n  while ((match = placeholderRegex.exec(sql)) !== null) {\n    placeholders.push({\n      index: parseInt(match[1], 10),\n      position: match.index,\n    });\n  }\n\n  // Replace placeholders in reverse order to maintain positions\n  if (placeholders.length > 0) {\n    // Sort by position in reverse order\n    placeholders.sort((a, b) => b.position - a.position);\n    \n    // Replace each $N with ?\n    for (const placeholder of placeholders) {\n      mysqlSql = mysqlSql.substring(0, placeholder.position) + \n                 '?' + \n                 mysqlSql.substring(placeholder.position + `$${placeholder.index}`.length);\n    }\n  }\n\n  // Convert double-quoted column names to backticks for MySQL\n  // Match \"columnName\" and replace with `columnName`\n  mysqlSql = mysqlSql.replace(/\"([^\"]+)\"/g, '`$1`');\n\n  // Convert PostgreSQL ON CONFLICT to MySQL ON DUPLICATE KEY UPDATE\n  mysqlSql = mysqlSql.replace(\n    /ON CONFLICT\\s*\\(([^)]+)\\)\\s*DO UPDATE SET\\s*(.+)/gi,\n    (match, conflictColumns, updateClause) => {\n      // Convert EXCLUDED.columnName to VALUES(columnName)\n      const convertedUpdate = updateClause.replace(/EXCLUDED\\.(\\w+)/gi, 'VALUES($1)');\n      return `ON DUPLICATE KEY UPDATE ${convertedUpdate}`;\n    }\n  );\n\n  // Remove MySQL-incompatible syntax like ::jsonb (legacy PostgreSQL syntax)\n  mysqlSql = mysqlSql.replace(/::jsonb/g, '');\n  mysqlSql = mysqlSql.replace(/::json/g, '');\n\n  return mysqlSql;\n}\n\n/**\n * Initialize database\n */\nexport async function initializeDatabase(): Promise<void> {\n  const { ensureDatabase, initializeTables } = await import(\"./mysql\");\n  await ensureDatabase();\n  await initializeTables();\n}\n\n/**\n * Test database connection\n */\nexport async function testConnection(): Promise<boolean> {\n  try {\n    const { testConnection } = await import(\"./mysql\");\n    return await testConnection();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Get database type\n */\nexport function getDatabaseType(): \"mysql\" | \"none\" {\n  return \"mysql\";\n}\n","/**\r\n * Image utility functions\r\n */\r\n\r\n/**\r\n * Get placeholder image URL\r\n * Uses external service for Next.js Image component compatibility\r\n * @param width - Image width in pixels (default: 600)\r\n * @param height - Image height in pixels (default: 600)\r\n * @returns Placeholder image URL\r\n */\r\nexport function getPlaceholderImage(width: number = 600, height: number = 600): string {\r\n  // Use placehold.co service for Next.js Image compatibility\r\n  const text = encodeURIComponent(`${width}x${height}`);\r\n  return `https://placehold.co/${width}x${height}/f3f4f6/9ca3af?text=${text}`;\r\n}\r\n\r\n/**\r\n * Validate if a string is a valid image URL\r\n * @param url - URL to validate\r\n * @returns true if valid, false otherwise\r\n */\r\nexport function validateImageUrl(url: string | null | undefined): boolean {\r\n  if (!url || typeof url !== 'string' || url.trim() === '') {\r\n    return false;\r\n  }\r\n\r\n  const trimmedUrl = url.trim();\r\n\r\n  // Check if it's a base64 data URL (be more lenient)\r\n  if (trimmedUrl.startsWith('data:image') || trimmedUrl.startsWith('data:')) {\r\n    // For base64, be more lenient - just check basic structure\r\n    // The browser will handle actual image validation\r\n    if (trimmedUrl.includes(';base64,') && trimmedUrl.length > 50) {\r\n      // Basic validation - let the browser handle the rest\r\n      return true;\r\n    }\r\n    // Even if it doesn't have ;base64,, if it's a data: URL and long enough, accept it\r\n    if (trimmedUrl.startsWith('data:image') && trimmedUrl.length > 50) {\r\n      return true;\r\n    }\r\n    // Fallback to strict validation\r\n    return validateBase64Image(trimmedUrl);\r\n  }\r\n\r\n  // Check if it's a blob URL\r\n  if (trimmedUrl.startsWith('blob:')) {\r\n    return true;\r\n  }\r\n\r\n  // Check if it's a relative path\r\n  if (trimmedUrl.startsWith('/')) {\r\n    return true;\r\n  }\r\n\r\n  // Check if it's a valid HTTP/HTTPS URL\r\n  try {\r\n    const urlObj = new URL(trimmedUrl);\r\n    return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate and check if base64 image is valid\r\n * @param base64 - Base64 string to validate\r\n * @returns true if valid, false otherwise\r\n */\r\nexport function validateBase64Image(base64: string): boolean {\r\n  if (!base64 || typeof base64 !== 'string') {\r\n    return false;\r\n  }\r\n\r\n  // Check if it starts with data:image\r\n  if (!base64.startsWith('data:image/')) {\r\n    return false;\r\n  }\r\n\r\n  // Check if it has the base64 prefix\r\n  if (!base64.includes(';base64,')) {\r\n    return false;\r\n  }\r\n\r\n  // Extract the base64 part\r\n  const base64Part = base64.split(';base64,')[1];\r\n  if (!base64Part || base64Part.trim() === '') {\r\n    return false;\r\n  }\r\n\r\n  // Check if base64 string is valid (basic check)\r\n  // Base64 should only contain A-Z, a-z, 0-9, +, /, and = characters\r\n  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;\r\n  if (!base64Regex.test(base64Part)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if it's not too large (more than 15MB base64 is problematic)\r\n  // But allow up to 15MB to handle high-quality product images\r\n  if (base64.length > 15 * 1024 * 1024) {\r\n    return false;\r\n  }\r\n\r\n  // Additional check: ensure the base64 part is not empty after trimming\r\n  if (base64Part.trim().length === 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Normalize image URL (convert relative to absolute, validate, etc.)\r\n * @param url - URL to normalize\r\n * @param baseUrl - Base URL for relative paths (default: current origin)\r\n * @returns Normalized URL or empty string if invalid\r\n */\r\nexport function normalizeImageUrl(\r\n  url: string | null | undefined,\r\n  baseUrl?: string\r\n): string {\r\n  if (!url || typeof url !== 'string' || url.trim() === '') {\r\n    return '';\r\n  }\r\n\r\n  const trimmedUrl = url.trim();\r\n\r\n  // If it's already a valid absolute URL or base64, return as is\r\n  if (trimmedUrl.startsWith('http://') || \r\n      trimmedUrl.startsWith('https://') || \r\n      trimmedUrl.startsWith('data:image') ||\r\n      trimmedUrl.startsWith('data:') || // More lenient - accept any data: URL\r\n      trimmedUrl.startsWith('blob:')) {\r\n    return trimmedUrl;\r\n  }\r\n\r\n  // Check if it might be a base64 string without the data: prefix\r\n  // Base64 strings are typically very long and contain only base64 characters\r\n  if (trimmedUrl.length > 100 && /^[A-Za-z0-9+/=]+$/.test(trimmedUrl)) {\r\n    // It might be a raw base64 string, but we can't use it without the data:image prefix\r\n    // Return empty string - the caller should handle this\r\n    return '';\r\n  }\r\n\r\n  // If it's a relative path starting with /\r\n  if (trimmedUrl.startsWith('/')) {\r\n    // If baseUrl is provided, use it; otherwise use current origin\r\n    if (baseUrl) {\r\n      return `${baseUrl}${trimmedUrl}`;\r\n    }\r\n    // In browser, use window.location.origin\r\n    if (typeof window !== 'undefined') {\r\n      return `${window.location.origin}${trimmedUrl}`;\r\n    }\r\n    // In server, return relative path (will be handled by Next.js)\r\n    return trimmedUrl;\r\n  }\r\n\r\n  // If it doesn't start with /, try to construct a full URL\r\n  // This handles cases where URL might be missing protocol\r\n  try {\r\n    const urlObj = new URL(trimmedUrl);\r\n    return urlObj.toString();\r\n  } catch {\r\n    // If URL construction fails, return empty string\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * Preload an image\r\n * @param url - Image URL to preload\r\n * @returns Promise that resolves when image is loaded or rejects on error\r\n */\r\nexport function preloadImage(url: string): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    if (!validateImageUrl(url)) {\r\n      reject(new Error('Invalid image URL'));\r\n      return;\r\n    }\r\n\r\n    // For base64 images, we can't use Image object, so just resolve\r\n    if (url.startsWith('data:image') || url.startsWith('blob:')) {\r\n      resolve();\r\n      return;\r\n    }\r\n\r\n    const img = new Image();\r\n    img.onload = () => resolve();\r\n    img.onerror = () => reject(new Error('Failed to load image'));\r\n    img.src = url;\r\n  });\r\n}\r\n\r\n/**\r\n * Get cache key for an image URL\r\n * Removes query parameters that are used for cache busting\r\n * @param url - Image URL\r\n * @returns Cache key\r\n */\r\nexport function getImageCacheKey(url: string): string {\r\n  if (!url || typeof url !== 'string') {\r\n    return '';\r\n  }\r\n\r\n  // Remove cache busting parameters\r\n  try {\r\n    const urlObj = new URL(url);\r\n    urlObj.searchParams.delete('_retry');\r\n    urlObj.searchParams.delete('_t');\r\n    urlObj.searchParams.delete('_cache');\r\n    return urlObj.toString();\r\n  } catch {\r\n    // If URL parsing fails, remove common cache busting patterns manually\r\n    return url\r\n      .replace(/[?&]_retry=\\d+/g, '')\r\n      .replace(/[?&]_t=\\d+/g, '')\r\n      .replace(/[?&]_cache=\\d+/g, '');\r\n  }\r\n}\r\n\r\n/**\r\n * Check if image URL needs cache busting\r\n * @param url - Image URL\r\n * @returns true if cache busting is needed\r\n */\r\nexport function needsCacheBusting(url: string): boolean {\r\n  if (!url || typeof url !== 'string') {\r\n    return false;\r\n  }\r\n\r\n  // Base64 and blob URLs don't need cache busting\r\n  if (url.startsWith('data:image') || url.startsWith('blob:')) {\r\n    return false;\r\n  }\r\n\r\n  // Check if URL already has cache busting parameters\r\n  return !url.includes('_t=') && !url.includes('_retry=');\r\n}\r\n\r\n/**\r\n * Add cache busting to URL\r\n * @param url - Image URL\r\n * @returns URL with cache busting parameter\r\n */\r\nexport function addCacheBusting(url: string): string {\r\n  if (!url || typeof url !== 'string') {\r\n    return url;\r\n  }\r\n\r\n  // Don't add cache busting to base64 or blob URLs\r\n  if (url.startsWith('data:image') || url.startsWith('blob:')) {\r\n    return url;\r\n  }\r\n\r\n  const separator = url.includes('?') ? '&' : '?';\r\n  return `${url}${separator}_t=${Date.now()}`;\r\n}\r\n\r\n","/**\r\n * Utility functions for product data normalization\r\n */\r\n\r\n/**\r\n * Normalize images array from database\r\n * Handles various formats: string, array, null, undefined\r\n */\r\nexport function normalizeImages(images: any): string[] {\r\n  // اگر null یا undefined است\r\n  if (images == null) {\r\n    return [];\r\n  }\r\n\r\n  // اگر قبلاً array است\r\n  if (Array.isArray(images)) {\r\n    return images\r\n      .filter((img): img is string => \r\n        img != null && \r\n        typeof img === 'string' && \r\n        img.trim() !== ''\r\n      )\r\n      .map(img => img.trim());\r\n  }\r\n\r\n  // اگر string است، سعی کن parse کن\r\n  if (typeof images === 'string') {\r\n    // اگر string خالی است\r\n    if (images.trim() === '') {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const parsed = JSON.parse(images);\r\n      if (Array.isArray(parsed)) {\r\n        return parsed\r\n          .filter((img): img is string => \r\n            img != null && \r\n            typeof img === 'string' && \r\n            img.trim() !== ''\r\n          )\r\n          .map(img => img.trim());\r\n      }\r\n      // اگر یک string واحد است\r\n      if (typeof parsed === 'string' && parsed.trim() !== '') {\r\n        return [parsed.trim()];\r\n      }\r\n    } catch (e) {\r\n      // اگر parse ناموفق بود، خود string را به عنوان یک تصویر در نظر بگیر\r\n      return [images.trim()];\r\n    }\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\n/**\r\n * Normalize tags array from database\r\n */\r\nexport function normalizeTags(tags: any): string[] {\r\n  if (tags == null) {\r\n    return [];\r\n  }\r\n\r\n  if (Array.isArray(tags)) {\r\n    return tags\r\n      .filter((tag): tag is string => \r\n        tag != null && \r\n        typeof tag === 'string' && \r\n        tag.trim() !== ''\r\n      )\r\n      .map(tag => tag.trim());\r\n  }\r\n\r\n  if (typeof tags === 'string') {\r\n    if (tags.trim() === '') {\r\n      return [];\r\n    }\r\n    try {\r\n      const parsed = JSON.parse(tags);\r\n      if (Array.isArray(parsed)) {\r\n        return parsed\r\n          .filter((tag): tag is string => \r\n            tag != null && \r\n            typeof tag === 'string' && \r\n            tag.trim() !== ''\r\n          )\r\n          .map(tag => tag.trim());\r\n      }\r\n    } catch (e) {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\n/**\r\n * Normalize specifications object from database\r\n */\r\nexport function normalizeSpecifications(specs: any): Record<string, unknown> {\r\n  if (specs == null) {\r\n    return {};\r\n  }\r\n\r\n  if (typeof specs === 'object' && specs !== null && !Array.isArray(specs)) {\r\n    return specs;\r\n  }\r\n\r\n  if (typeof specs === 'string') {\r\n    if (specs.trim() === '') {\r\n      return {};\r\n    }\r\n    try {\r\n      const parsed = JSON.parse(specs);\r\n      if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {\r\n        return parsed;\r\n      }\r\n    } catch (e) {\r\n      return {};\r\n    }\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\n"],"names":[],"mappings":"2XAEO,IAAM,EAAgB,CAAA,EAAA,AAD7B,EAAA,CAAA,CAAA,OAC6B,uBAAA,AAAuB,EAChD,WAAa,MAAM,AAAI,MAAM,wOAA0O,EACvQ,sEACA,oEAHG,IAAM,EAAgB,CAAA,EAD7B,AAC6B,EAD7B,CAAA,CAAA,OAC6B,uBAAA,AAAuB,EAChD,WAAa,MAAM,AAAI,MAAM,wOAA0O,EACvQ,kDACA,+ICJJ,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OCMO,eAAe,EACpB,CAAW,CACX,EAAgB,EAAE,EAElB,GAAI,CACF,GAAM,UAAE,CAAQ,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAEf,EAAW,AA2DrB,SAAS,AAAkB,CAAW,EACpC,IAMI,EANA,EAAW,EAIT,EAAmB,WACnB,EAA2D,EAAE,CAEnE,KAAO,AAAyC,KAAM,GAA9C,EAAQ,EAAiB,IAAI,CAAC,EAAA,CAAI,EACxC,EAAa,IAAI,CAAC,CAChB,MAAO,SAAS,CAAK,CAAC,EAAE,CAAE,IAC1B,SAAU,EAAM,KAAK,AACvB,GAIF,GAAI,EAAa,MAAM,CAAG,EAKxB,CAL2B,GAKtB,IAAM,KAHX,EAAa,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,QAAQ,CAAG,EAAE,QAAQ,EAGzB,GACxB,EAAW,EAAS,MADkB,GACT,CAAC,EAAG,EAAY,QAAQ,EAC1C,IACA,EAAS,SAAS,CAAC,EAAY,QAAQ,CAAG,CAAC,CAAC,EAAE,EAAY,KAAK,CAAA,CAAE,CAAC,MAAM,EAsBvF,OAFA,AAEO,EAFI,CADX,EAAW,CAVX,EAAW,CAHX,EAAW,EAAS,OAAO,CAAC,aAAc,OAAA,EAGtB,OAAO,CACzB,qDACA,CAAC,EAAO,EAAiB,KAEvB,IAAM,EAAkB,EAAa,OAAO,CAAC,oBAAqB,cAClE,MAAO,CAAC,wBAAwB,EAAE,EAAA,CAAiB,AACrD,EAAA,EAIkB,OAAO,CAAC,WAAY,GAAA,EACpB,OAAO,CAAC,UAAW,GAGzC,EA1GuC,GACnC,OAAO,MAAM,EAAY,EAAU,EACrC,CAAE,MAAO,EAAY,CAOnB,MANA,QAAQ,KAAK,CAAC,4BAA6B,CACzC,aACA,EACA,MAAO,GAAO,QACd,KAAM,GAAO,IACf,GACM,CACR,CACF,CDhBA,eAAe,EAAW,CAAU,EAClC,GAAI,CACF,IAAM,EAAU,MAAM,EACpB,yDACA,CAAC,EAAG,EAGN,GAAI,CAAC,EACH,OADY,AACL,KA2BT,MAvB+B,CAuBxB,AAtBL,GAAG,CAAO,CACV,OGjBC,AHiBO,SGjBE,AAAgB,CAAW,EAEzC,GAAc,MAAV,AAAgB,EAClB,MAAO,EAAE,CAIX,GAAI,MAAM,OAAO,CAAC,GAChB,MADyB,CAClB,EACJ,MAAM,CAAC,AAAC,GACA,MAAP,GACe,UAAf,OAAO,GACP,AAAe,OAAX,IAAI,IAET,GAAG,CAAC,GAAO,EAAI,IAAI,IAIxB,GAAsB,UAAlB,OAAO,EAAqB,CAE9B,GAAsB,IAAI,CAAtB,EAAO,IAAI,GACb,MAAO,EAAE,CAGX,GAAI,CACF,IAAM,EAAS,KAAK,KAAK,CAAC,GAC1B,GAAI,MAAM,OAAO,CAAC,GAChB,MADyB,CAClB,EACJ,MAAM,CAAC,AAAC,GACA,MAAP,GACe,UAAf,OAAO,GACQ,KAAf,EAAI,IAAI,IAET,GAAG,CAAC,GAAO,EAAI,IAAI,IAGxB,GAAsB,UAAlB,OAAO,GAAyC,IAAI,CAAtB,EAAO,IAAI,GAC3C,MAAO,CAAC,EAAO,IAAI,GAAG,AAE1B,CAAE,MAAO,EAAG,CAEV,MAAO,CAAC,EAAO,IAAI,GAAG,AACxB,CACF,CAEA,MAAO,EAAE,AACX,EH7B8B,EAAQ,MAAM,EACtC,KAAM,AGiCL,SAAS,AAAc,CAAS,EACrC,GAAY,MAAR,AAAc,EAChB,MAAO,EAAE,CAGX,GAAI,MAAM,OAAO,CAAC,GAChB,IADuB,GAChB,EACJ,MAAM,CAAC,AAAC,GACP,AAAO,SACQ,UAAf,OAAO,GACP,AAAe,OAAX,IAAI,IAET,GAAG,CAAC,GAAO,EAAI,IAAI,IAGxB,GAAoB,UAAhB,OAAO,EAAmB,CAC5B,GAAoB,IAAI,CAApB,EAAK,IAAI,GACX,MAAO,EAAE,CAEX,GAAI,CACF,IAAM,EAAS,KAAK,KAAK,CAAC,GAC1B,GAAI,MAAM,OAAO,CAAC,GAChB,MADyB,CAClB,EACJ,MAAM,CAAC,AAAC,GACP,AAAO,SACQ,UAAf,OAAO,GACQ,KAAf,EAAI,IAAI,IAET,GAAG,CAAC,GAAO,EAAI,IAAI,GAE1B,CAAE,MAAO,EAAG,CAEZ,CACF,CAEA,MAAO,EAAE,AACX,EHrE0B,EAAQ,IAAI,EAChC,eGyEC,AHzEe,SGyEN,AAAwB,CAAU,EAChD,GAAI,AAAS,MAAM,EACjB,MAAO,CAAC,EAGV,GAAqB,UAAjB,OAAO,GAAgC,OAAV,GAAkB,CAAC,MAAM,OAAO,CAAC,GAChE,KADwE,EACjE,EAGT,GAAI,AAAiB,iBAAV,EAAoB,CAC7B,GAAqB,IAAI,CAArB,EAAM,IAAI,GACZ,MAAO,CAAC,EAEV,GAAI,CACF,IAAM,EAAS,KAAK,KAAK,CAAC,GAC1B,GAAsB,UAAlB,OAAO,GAAkC,OAAX,GAAmB,CAAC,MAAM,OAAO,CAAC,GAClE,MAD2E,CACpE,CAEX,CAAE,MAAO,EAAG,CAEZ,CACF,CAEA,MAAO,CAAC,CACV,EHjG8C,EAAQ,cAAc,EAC9D,MAAO,OAAO,EAAQ,KAAK,EAC3B,cAAe,EAAQ,aAAa,CAAG,OAAO,EAAQ,aAAa,OAAI,EACvE,WAAY,OAAO,EAAQ,UAAU,EACrC,SAAS,CAAQ,EAAQ,OAAO,CAChC,SAAS,CAAQ,EAAQ,OAAO,CAChC,YAAY,CAAQ,EAAQ,UAAU,CACtC,oBAAoB,CAAQ,EAAQ,kBAAkB,CACtD,oBAAoB,CAAQ,EAAQ,kBAAkB,CACtD,gBAAiB,AAA4B,SAApB,eAAe,OAAyC,IAA5B,EAAQ,eAAe,CACxE,OAAO,EAAQ,eAAe,EAC9B,KACJ,gBAA6C,OAA5B,EAAQ,eAAe,EAAyC,SAA5B,EAAQ,eAAe,CACxE,OAAO,EAAQ,eAAe,EAC9B,KACJ,UAAW,EAAQ,SAAS,YAAY,KAAO,EAAQ,SAAS,CAAG,IAAI,KAAK,EAAQ,SAAS,EAC7F,UAAW,EAAQ,SAAS,YAAY,KAAO,EAAQ,SAAS,CAAG,IAAI,KAAK,EAAQ,SAAS,CAC/F,CAGF,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,uCAAwC,GAC/C,IACT,CACF,CAEO,eAAe,EAAiB,QACrC,CAAM,CAGP,EACC,GAAM,IAAE,CAAE,CAAE,CAAG,MAAM,EACf,EAAU,MAAM,EAAW,GAEjC,GAAI,CAAC,EACH,MAAO,CADK,AAEV,MAAO,uBACP,YAAa,6BACf,EAGF,IAAM,EAAe,EAAQ,MAAM,EAAE,CAAC,EAAE,EEzDnC,AFyDuC,SEzD9B,AAAoB,EAAgB,GAAG,CAAE,EAAiB,GAAG,EAE3E,IAAM,EAAO,mBAAmB,CAAA,EAAG,EAAM,CAAC,EAAE,EAAA,CAAQ,EACpD,MAAO,CAAC,qBAAqB,EAAE,EAAM,CAAC,EAAE,EAAO,oBAAoB,EAAE,EAAA,CACvE,AAD6E,EFsDX,KAAM,KAChE,EAAa,GAAG,QAAQ,UAAU,aAAE,GAAI,CAChC,EAAQ,KAAK,CAC3B,EAD8B,EACxB,EAAc,EADgB,AACR,WAAW,EAAI,CAAA,EAAG,EAAQ,IAAI,CAAC,cAAc,EAAE,EAAQ,EADJ,GACS,CAAC,uBAAuB,CAAC,CAEjH,MAAO,CACL,MAAO,CAAA,EAAG,EAAQ,IAAI,CAAC,MAAM,CAAC,CAC9B,YAAa,EAAY,SAAS,CAAC,EAAG,KACtC,SAAU,CACR,EAAQ,IAAI,CACZ,EAAQ,KAAK,EAAI,GACjB,EAAQ,QAAQ,EAAI,GACpB,cACA,mBACI,EAAQ,IAAI,EAAI,EAAE,CACvB,CACD,WAAY,CACV,UAAW,CACb,EACA,UAAW,CACT,MAAO,EAAQ,IAAI,CACnB,YAAa,EAAY,SAAS,CAAC,EAAG,KACtC,IAAK,EACL,SAAU,4BACV,OAAQ,CACN,CACE,IAAK,EACL,MAAO,KACP,OAAQ,IACR,IAAK,EAAQ,IAAI,AACnB,EACD,CACD,OAAQ,QACR,KAAM,SACR,EACA,QAAS,CACP,KAAM,sBACN,MAAO,EAAQ,IAAI,CACnB,YAAa,EAAY,SAAS,CAAC,EAAG,KACtC,OAAQ,CAAC,EAAa,AACxB,EACA,OAAQ,CACN,OAAO,EACP,QAAQ,EACR,UAAW,CACT,OAAO,EACP,QAAQ,EACR,oBAAqB,CAAC,EACtB,oBAAqB,QACrB,cAAe,CAAC,CAClB,CACF,CACF,CACF,CAEe,eAAe,EAAkB,QAC9C,CAAM,CAGP,EACC,GAAM,IAAE,CAAE,CAAE,CAAG,MAAM,EAErB,MACE,CAAA,EAAA,EAAA,IAAA,EAAC,MAAA,CAAI,UAAU,uCACb,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,MAAM,CAAA,CAAA,GACP,CAAA,EAAA,EAAA,GAAA,EAAC,OAAA,CAAK,UAAU,iDACd,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,aAAa,CAAA,CAAC,UAAW,MAE5B,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,MAAM,CAAA,CAAA,KAGb","ignoreList":[0]}